package main

// walletdb is a high performance SSD-oriented wallet store. if keeps track
// of balances of wallets idetinfied by [32]byte hashes and is designed to
// keep a balance between spatial and temporal efficiency. It is capable of
// processing tens of thousands of transactions per second.

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"os"
	"time"
)

const (
	size       = int(sha256.Size)
	size64     = int64(size)
	NBuckets   = int64(2024)
	loadFactor = int64(2)
)

type Transaction struct {
	hash     Hash
	value    int64
	response chan bool
}

type Bucket struct {
	bucket int64
	data   []byte
}

type Account struct {
	bucketPoisition int64
	balance         int64
}

func (b *Bucket) HasHash(hash Hash, remaining int) *Account {
	if remaining > size {
		remaining = size
	}
	for account := 0; account < remaining; account++ {
		check := true
		for n := 0; n < size; n++ {
			if b.data[account*accBytes+n] == hash[n] {
				check = false
				break
			}
		}
		if check {
			balance := binary.LittleEndian.Uint64(b.data[account*accBytes+size : account*accBytes+size+8])
			return &Account{bucketPosition: account, int64(balance)}
		}
	}
	return nil
}

func (b *Bucket) Overflow() int64 {
	return int64(binary.LittleEndian.Uint64(
		b.data[bucketSize64*accBytes64 : bucketSize64*accBytes64+8]))
}

func (w *walletStore) readBucket(bucket int64) *Bucket {
	data := make([]byte, bucketBytes)
	_, err := w.file.Seek(bucket*bucketBytes64+header64, 0)
	if err != nil {
		panic(err)
	}
	n, err := w.file.Read(data)
	if n != int(bucketBytes) {
		w.file.Close()
		panic(err)
	}
	return &Bucket{bucket: bucket, data: data}
}

type Hash [size]byte

func CreateWalletStore(filepath string, bitsForBucket byte, epoch uint64) *walletStore {
	if bitsForBucket < 12 {
		panic("bitsForBucket too small")
	}
	filesize := (1<<bitsForBucket)*bucketBytes64 + header64
	file, err := os.Create(filepath)
	if err != nil {
		panic(err)
	}
	file.Close()
	if err := os.Truncate(filepath, int64(filesize)); err != nil {
		panic(err)
	}
	file, err = os.OpenFile(filepath, os.O_RDWR, os.ModeExclusive)
	if err != nil {
		panic(err)
	}
	if _, err := file.Seek(0, 0); err != nil {
		panic(err)
	}
	head := []byte{bitsForBucket, 0, 0, 0, 0, 0, 0, 0, 0}
	binary.LittleEndian.PutUint64(head, epoch)
	if n, err := file.Write(head); n != header {
		panic(err)
	}
	return &walletStore{
		file:             file,
		bitsForBucket:    int(bitsForBucket),
		mask:             1<<bitsForBucket - 1,
		bitsCount:        make([]uint8, 1<<bitsForBucket),
		freeOverflows:    make([]int64, 0),
		bucketCount:      1 << bitsForBucket,
		isDoubling:       false,
		bitsTransferered: 0,
		newWallet:        nil,
		isReady:          true,
		transaction:      make(chan Transaction),
		doubleJob:        make(chan int64),
		stop:             make(chan bool),
	}
}

func OpenWalletStore(filepath string) *walletStore {
	w := walletStore{}
	stat, err := os.Stat(filepath)
	if err != nil {
		panic(err)
	}
	file, err := os.OpenFile(filepath, os.O_RDWR, os.ModeExclusive)
	if err != nil {
		panic(err)
	}
	head := make([]byte, header)
	n, err := file.Read(head)
	if n != header {
		file.Close()
		panic(err)
	}
	if (stat.Size()-header64)%bucketBytes64 != 0 {
		file.Close()
		panic(err)
	}
	w.file = file
	w.bitsForBucket = int(head[0])
	w.bucketCount = (stat.Size() - header64) / bucketBytes64
	w.mask = 1<<w.bitsForBucket - 1
	w.bitsCount = make([]uint8, w.mask+1)
	overflowBuckets := make(map[int64]struct{})
	for bucket := int64(0); bucket <= w.mask; bucket++ {
		data := w.mustReadBucket(bucket)
		for {
			for n := int64(0); n < bucketSize64; n++ {
				iszero := true
				for i := int64(0); i < accBytes64; i++ {
					if data[n*accBytes64+i] != 0 {
						iszero = false
						break
					}
				}
				if iszero {
					break
				}
				w.bitsCount[n] += 1
			}
			nextBucket := ReadBucketOverflow(data)
			if nextBucket == 0 {
				break
			}
			overflowBuckets[nextBucket] = struct{}{}
			data = w.mustReadBucket(nextBucket)
		}
	}
	w.freeOverflows = make([]int64, 0)
	for bucket := w.mask + 1; bucket < w.bucketCount; bucket++ {
		if _, ok := overflowBuckets[bucket]; !ok {
			w.freeOverflows = append(w.freeOverflows, bucket)
		}
	}
	w.isReady = true
	w.transaction = make(chan Transaction)
	w.doubleJob = make(chan int64)
	w.stop = make(chan bool)
	return &w
}

func (w *walletStore) Start() {
	go func() {
		for {
			select {
			case t := <-w.transaction:
				t.response <- w.addTo(t.hash, t.value)
			case bucket := <-w.doubleJob:
				w.continueDuplication(bucket)
			case <-w.stop:
				close(w.transaction)
				close(w.doubleJob)
				close(w.stop)
				return
			}
		}
	}()
}

type walletStore struct {
	file          *os.File
	bitsForBucket int
	mask          int64
	bitsCount     []uint8 // number of items in the bucket
	freeOverflows []int64
	bucketCount   int64
	isReady       bool
	// for user when the map is doubling
	isDoubling       bool
	bitsTransferered int64
	newWallet        *walletStore
	transaction      chan Transaction
	doubleJob        chan int64
	stop             chan bool
}

func (w *walletStore) mustReadBucket(bucket int64) []byte {
	data := make([]byte, bucketBytes)
	_, err := w.file.Seek(bucket*bucketBytes64+header64, 0)
	if err != nil {
		panic(err)
	}
	n, err := w.file.Read(data)
	if n != int(bucketBytes) {
		w.file.Close()
		panic(err)
	}
	return data
}

func (w *walletStore) mustWriteBucket(data []byte, bucket int64) {
	if len(data) < bucketBytes {
		data = append(data, make([]byte, bucketBytes-len(data))...)
	}
	var n int
	var err error
	if bucket == -1 {
		if _, err := w.file.Seek(0, 2); err != nil {
			w.file.Close()
			panic(err)
		}
		n, err = w.file.Write(data)
	} else {
		if _, err := w.file.Seek(bucket*bucketBytes64+header64, 0); err != nil {
			panic(err)
		}
		n, err = w.file.Write(data)
	}
	if n != bucketBytes {
		w.file.Close()
		panic(err)
	}
}

func (w *walletStore) mustWriteAccount(accData []byte, bucket int64, position int64) {
	if len(accData) != accBytes {
		panic("wrong accData bytes")
	}
	offset := bucket*bucketBytes64 + position*accBytes64 + header64
	if _, err := w.file.Seek(offset, 0); err != nil {
		panic(err)
	}
	nBytes, err := w.file.Write(accData)
	if nBytes != len(accData) {
		panic(err)
	}
}

func (w *walletStore) mustWriteBalance(value uint64, bucket int64, position int64) {
	offset := bucket*bucketBytes64 + position*accBytes64 + size64 + header64
	data := make([]byte, 8)
	BytesUint64(data, 0, value)
	if _, err := w.file.Seek(offset, 0); err != nil {
		panic(err)
	}
	nBytes, err := w.file.Write(data)
	if nBytes != 8 {
		panic(err)
	}
}

func (w *walletStore) mustWriteOverflow(bucket, overflow int64) {
	overflowBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(overflowBytes, uint64(overflow))
	offset := bucket*bucketBytes64 + bucketSize64*accBytes64 + header64
	if _, err := w.file.Seek(offset, 0); err != nil {
		panic(err)
	}
	nBytes, err := w.file.Write(overflowBytes)
	if nBytes != 8 {
		panic(err)
	}
}

func (w *walletStore) insertBulk(accounts []byte, bucket int64) {
	bucketCounts := len(accounts) / (accBytes * bucketSize)
	if len(accounts)%(accBytes*bucketSize) > 0 {
		bucketCounts++
	}
	if bucketCounts == 0 {
		w.mustWriteBucket(accounts, bucket)
		return
	}
	for n := 0; n < bucketCounts; n++ {
		w.bucketCount++
		if n < bucketCounts-1 {
			block := append(accounts[n*accBytes*bucketSize:(n+1)*accBytes*bucketSize], []byte{0, 0, 0, 0, 0, 0, 0, 0}...)
			BytesUint64(block, accBytes64*bucketSize64, uint64(w.bucketCount))
			w.mustWriteBucket(block, -1)
		} else {
			block := accounts[(bucketCounts-1)*accBytes*bucketSize:]
			w.mustWriteBucket(block, -1)
		}
	}
}

func (w *walletStore) transferBuckets(starting, N int64) {
	// mask to test new bit
	highBit := uint64(1 << (w.newWallet.bitsForBucket - 1))

	for bucket := starting; bucket < starting+N; bucket++ {
		lBitBucket := make([]byte, 0, 2*accBytes*size)
		hBitBucket := make([]byte, 0, 2*accBytes*size)
		// loop over buckets and overflowbuckets
		count := uint8(0)
		itemsCount := w.bitsCount[starting]
		bucketchain := bucket
		for {
			oldBucket := w.mustReadBucket(bucketchain)
			for n := 0; n < bucketSize; n++ {
				count++
				if count > itemsCount {
					break
				}
				hashBit := (uint64(oldBucket[accBytes*n]) +
					(uint64(oldBucket[accBytes*n+1]) << 8) +
					(uint64(oldBucket[accBytes*n+2]) << 16) +
					(uint64(oldBucket[accBytes*n+3]) << 24)) & highBit
				if hashBit == highBit {
					hBitBucket = append(hBitBucket, oldBucket[n*accBytes:(n+1)*accBytes]...)
				} else {
					lBitBucket = append(lBitBucket, oldBucket[n*accBytes:(n+1)*accBytes]...)
				}
			}
			bucketchain = ReadBucketOverflow(oldBucket)
			if bucketchain == 0 {
				break
			}
		}
		w.newWallet.insertBulk(lBitBucket, bucket)
		w.newWallet.insertBulk(hBitBucket, bucket+int64(highBit))
		w.bitsTransferered = starting + N - 1
	}
}

func (w *walletStore) continueDuplication(bucket int64) {
	//for bucket := int64(0); bucket < 1<<w.bitsForBucket; bucket += NBuckets {
	w.transferBuckets(bucket, NBuckets)
	if bucket+NBuckets < 1<<w.bitsForBucket {
		go func() {
			sleep, _ := time.ParseDuration("10ms")
			time.Sleep(sleep)
			w.doubleJob <- bucket + NBuckets
		}()
	} else {
		oldFileName := w.file.Name()
		w.file.Close()
		newFileName := w.newWallet.file.Name()
		w.newWallet.file.Close()
		os.Rename(newFileName, oldFileName)
		file, err := os.OpenFile(oldFileName, os.O_RDWR, os.ModeExclusive)
		if err != nil {
			panic(err)
		}
		w.file = file
		w.bitsForBucket = w.newWallet.bitsForBucket
		w.mask = w.newWallet.mask
		w.bitsCount = w.newWallet.bitsCount
		w.freeOverflows = w.newWallet.freeOverflows
		w.bucketCount = w.newWallet.bucketCount
		w.isDoubling = false
		w.bitsTransferered = 0
		w.newWallet = nil
		w.isReady = true
	}
}

func (w *walletStore) startDuplication() {
	w.isDoubling = true
	w.newWallet = CreateWalletStore("wallet_duplicate.tmp", byte(w.bitsForBucket)+1, 0)
	w.newWallet.isReady = false
	w.bitsTransferered = 0
	w.continueDuplication(0)
}

func (w *walletStore) swapLast(bucketData []byte, bucket int64, count int, item int64) {
	totalItems := int64(w.bitsCount[bucket])
	bucketsAhead := (totalItems - int64(item)) / bucketSize64
	itemsAhead := int64(item) + (totalItems-int64(item))%bucketSize64
	if bucketsAhead+itemsAhead > 0 {
		bucketD := bucketData
		for n := int64(0); n < bucketsAhead; n++ {
			nextBucket := ReadBucketOverflow(bucketD)
			bucketD = w.mustReadBucket(nextBucket)
		}
		account := bucketD[itemsAhead*accBytes64 : (itemsAhead+1)*accBytes64]
		w.mustWriteAccount(account, bucket, item)
		w.mustWriteAccount(make([]byte, accBytes64), bucketsAhead, itemsAhead)
	} else {
		w.mustWriteAccount(make([]byte, accBytes64), bucket, item)
	}
}

func (w *walletStore) addOverflow(bucket int64) {
	var newBucket int64
	if l := len(w.freeOverflows); l > 0 {
		newBucket = w.freeOverflows[l-1]
		w.freeOverflows = w.freeOverflows[0 : l-1]
	} else {
		w.bucketCount++
		block := make([]byte, bucketBytes)
		if _, err := w.file.Seek(0, 2); err != nil {
			panic(err)
		}
		n, err := w.file.Write(block)
		if n != bucketBytes {
			panic(err)
		}
		newBucket = w.bucketCount - 1
	}
	w.mustWriteOverflow(bucket, newBucket)
	if w.isReady && (!w.isDoubling) && (w.bucketCount > loadFactor*(1<<w.bitsForBucket)) {
		w.startDuplication()
	}
}

func (ws *walletStore) Balance(hash Hash) int64 {
	buckPos := HashToInt64(hash) & ws.mask
	wallet := ws
	if ws.isDoubling && buckPos < ws.bitsTransferered {
		buckPos = HashToInt64(hash) & ws.newWallet.mask
		wallet = ws.newWallet
	}
	countAccounts, totalAccounts := 0, int(wallet.bitsCount[buckPos])
	if totalAccounts == 0 {
		return -1
	}
	for {
		bucket := wallet.readBucket(buckPos)
		if acc := bucket.HasHash(hash, totalAccounts-countAccounts); acc != nil {
			return acc.balance
		}
		if countAccounts += bucketSize; countAccounts >= totalAccounts {
			return -1
		}
		// move to the next bucket
		buckPos = bucket.Overflow()
	}
}

// for value > 0 credit (and create if non-existent) or for value < 0 tries to
// debit (only if there is enough balance) an account associated to a hash.
// returns false if the account does not exists or there is no sufficient
// balance for debit.
// all operations are persisted to disc.
// any io failure causes panic: TODO: handle io errors
// the operation can create overflow buckets.
// if the balance of an account turns to zero after debit it is removed from
// the wallet in order to clear space.
func (ws *walletStore) addTo(hash Hash, value int64) bool {
	debit := value < 0
	bucket := HashToInt64(hash) & ws.mask
	wallet := ws
	if ws.isDoubling && bucket < ws.bitsTransferered {
		bucket = HashToInt64(hash) & ws.newWallet.mask
		wallet = ws.newWallet
	}
	data := wallet.mustReadBucket(bucket)
	bucketCopy := bucket
	countAccounts, totalAccounts := 0, wallet.bitsCount[bucket]
	for {

		for accBucket := int64(0); accBucket < bucketSize64; accBucket++ {
			countAccounts += 1
			if countAccounts > int(totalAccounts) {
				if !debit {
					// create and save new account
					newAccountData := append(hash[:], make([]byte, 8)...)
					BytesUint64(newAccountData, size64, uint64(value))
					wallet.mustWriteAccount(newAccountData, bucketCopy, accBucket)
					wallet.bitsCount[bucket] += 1
					// if bucket is full create a new overflow
					if accBucket == bucketSize64-1 {
						wallet.addOverflow(bucketCopy)
					}
				}
				return false // non-existing account
			}
			check := true
			for hashPos := int64(0); hashPos < size64; hashPos++ {
				if data[hashPos+accBucket*accBytes64] != hash[hashPos] {
					check = false
					break
				}
			}
			if check {
				newBalance := ReadBalanceOnBucket(data, accBucket) + value
				if newBalance > 0 {
					wallet.mustWriteBalance(uint64(newBalance), bucketCopy, accBucket)
					return true
				} else if newBalance == 0 {
					// remove account from database
					wallet.swapLast(data, bucketCopy, countAccounts, accBucket)
					wallet.bitsCount[bucket] -= 1
					return true
				} else {
					return false
				}
			}
		}
		// move to the next bucket
		bucketCopy = ReadBucketOverflow(data)
		data = wallet.mustReadBucket(bucketCopy)
	}
}

func ReadBalanceOnBucket(bucketData []byte, accItem int64) int64 {
	return int64(binary.LittleEndian.Uint64(
		bucketData[accItem*accBytes64+size64 : accItem*accBytes64+size64+8]))
}

func ReadBucketOverflow(bucketData []byte) int64 {
	return int64(binary.LittleEndian.Uint64(
		bucketData[bucketSize64*accBytes64 : bucketSize64*accBytes64+8]))
}

func BytesUint64(data []byte, start int64, value uint64) {
	b := make([]byte, 8)
	binary.LittleEndian.PutUint64(b, value)
	for n := int64(0); n < 8; n++ {
		data[start+n] = b[n]
	}
}

// converts (little endian) the first for bytes of the hash into a integer
func HashToInt64(hash Hash) int64 {
	return int64(hash[0]) + (int64(hash[1]) << 8) + (int64(hash[2]) << 16) + (int64(hash[3]) << 24)
}

func (w *walletStore) Credit(hash Hash, value uint64) {
	response := make(chan bool)
	w.transaction <- Transaction{hash: hash, value: int64(value), response: response}
	<-response
}

func (w *walletStore) Debit(hash Hash, value uint64) bool {
	response := make(chan bool)
	w.transaction <- Transaction{hash: hash, value: -int64(value), response: response}
	return <-response
}

func main() {
	w := CreateWalletStore("teste.txt", 12, 12)
	w.Start()
	b := make([]byte, size)
	var h Hash
	//st := time.Now()
	testmap := make(map[Hash]int64)
	for r := 0; r < 40000; r++ {
		rand.Read(b)
		for n := 0; n < size; n++ {
			h[n] = b[n]
		}
		w.Credit(h, 1)
		if balance, ok := testmap[h]; ok {
			testmap[h] = balance + 1
		} else {
			testmap[h] = 1
		}
	}
	sec, _ := time.ParseDuration("3s")
	fmt.Println(w.isDoubling)
	time.Sleep(sec)
	fmt.Println(w.bucketCount, 1<<w.bitsForBucket, w.isDoubling)
	erros := 0
	for hash, balance := range testmap {
		value := w.Balance(hash)
		if balance != value {
			erros++
		}
	}
	fmt.Println("Erros:", erros)
}
