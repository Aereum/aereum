type SingleFileHashDb struct {
	file       *os.File
	collisions map[Hash]struct{}
}

func (s *SingleFileHashDb) WriteAtBlock(hash Hash, segmentPosition int, b []byte) error {
	segment := int(hash[0]) + int(hash[1])<<8
	_, err := s.file.WriteAt(b, int64(segment*segmentSize+segmentPosition*sizeOnSegment))
	return err
}

func (s *SingleFileHashDb) Block(hash Hash) ([]byte, error) {
	segment := int(hash[0]) + int(hash[1])<<8
	bytes := make([]byte, segmentSize)
	n, err := s.file.ReadAt(bytes, int64(segment*segmentSize))
	if err != nil {
		return nil, err
	}
	if n != segmentSize {
		return nil, errCouldNotReadSegment
	}
	return bytes, nil
}

func (s *SingleFileHashDb) Exists(hash Hash) (bool, error) {
	if _, ok := s.collisions[hash]; ok {
		return true, nil
	}
	block, err := s.Block(hash)
	if err != nil {
		return false, err
	}
	hashEnd := hash[segmentsBytes:]
	for n := 0; n < maxHashesPerSegment; n++ {
		if bytes.Equal(hashEnd, block[n*sizeOnSegment:(n+1)*sizeOnSegment]) {
			return true, nil
		}
	}
	return false, nil
}

// returns false if exists, true if not exists and true,nil if not exists
// and has been incorporated
func (s *SingleFileHashDb) NewIfNotExists(hash Hash) (bool, error) {
	if _, ok := s.collisions[hash]; ok {
		return false, nil
	}
	block, err := s.Block(hash)
	if err != nil {
		return false, err
	}
	emptyHash := -1
	zeros := make([]byte, sizeOnSegment)
	hashEnd := hash[segmentsBytes:]
	for n := 0; n < maxHashesPerSegment; n++ {
		if bytes.Equal(hashEnd, block[n*sizeOnSegment:(n+1)*sizeOnSegment]) {
			return false, nil
		}
		if emptyHash == -1 && bytes.Equal(zeros, block[n*sizeOnSegment:(n+1)*sizeOnSegment]) {
			emptyHash = n
		}
	}
	if emptyHash == -1 {
		s.collisions[hash] = struct{}{}
		return true, nil
	}
	err = s.WriteAtBlock(hash, emptyHash, hashEnd)
	if err != nil {
		return true, err
	}
	return true, nil
}

func (s *SingleFileHashDb) RemoveIfExists(hash Hash) (bool, error) {
	if _, ok := s.collisions[hash]; ok {
		delete(s.collisions, hash)
		return true, nil
	}
	block, err := s.Block(hash)
	if err != nil {
		return false, err
	}
	hashEnd := hash[segmentsBytes:]
	for n := 0; n < maxHashesPerSegment; n++ {
		if bytes.Equal(hashEnd, block[n*sizeOnSegment:(n+1)*sizeOnSegment]) {
			zeros := make([]byte, sizeOnSegment)
			return true, s.WriteAtBlock(hash, n, zeros)
		}
	}
	return false, nil
}


func OpenOrCreateSingleFileHashDb(filePath string) *SingleFileHashDb {
	db := &SingleFileHashDb{
		collisions: make(map[Hash]struct{}),
	}
	segments := 1 << (8 * segmentsBytes)
	if stats, err := os.Stat(filePath); os.IsNotExist(err) {
		if file, err := os.Create(filePath); err != nil {
			return nil
		} else {
			bytes := make([]byte, segments*segmentSize)
			n, err := file.Write(bytes)
			if err != nil || n != len(bytes) {
				return nil
			}
			db.file = file
			return db
		}
	} else {
		if stats.Size() != int64(segments*segmentSize) {
			return nil
		}
		file, err := os.OpenFile(filePath, os.O_RDWR, os.ModeExclusive)
		if err != nil {
			return nil
		}
		db.file = file
		return db
	}
}
